extern mod sdl;
extern mod std;

use core::rand::RngUtil;
use core::libc::uint32_t;
use core::vec;
use core::comm::{stream, SharedChan};
use std::timer::sleep;
use std::uv;
use sdl::video::Color;

struct PixelResult {
  x: int,
  y: int,
  color: Color
}

fn main() {
  let iotask = ~uv::global_loop::get();
  let width = 800;
  let height = 600;
  let (port, chan) = stream();
  let chan = SharedChan(chan);

  do sdl::start {
    sdl::init([sdl::InitVideo]);
    sdl::wm::set_caption("raytracer", "raytracer");

    let rng = rand::Rng();
    let screen = match sdl::video::set_video_mode(width, height, 32, [sdl::video::HWSurface],
                                                              [sdl::video::DoubleBuf]) {
      Ok(screen) => screen,
      Err(err) => fail!(fmt!("failed to set video mode: %s", err))
    };

    for int::range(0, width) |x| {
      for int::range(0, height) |y| {
        let pixel = PixelResult {x: x, y: y, color: rng.gen::<Color>()};
        chan.send(pixel)
      }
    }

    loop main: {
      loop event: {
        match sdl::event::poll_event() {
          sdl::event::QuitEvent => break main,
          sdl::event::NoEvent => break event,
          _ => {}
        }
      }
      if(port.peek()) {
        screen.with_lock(|pixels| {
          unsafe {
            let pixels: &mut [uint32_t] = cast::transmute(pixels);
            let pitch = ((*screen.raw).pitch) as int;
            let format = ((*screen.raw).format);
            while(port.peek()) {
              let pixel = port.recv();
              pixels[pixel.y * pitch/ 4 + pixel.x] = pixel.color.to_mapped(format);
            }
          }
        });
        screen.flip();
      }
      sleep(iotask, 33);
    }

    sdl::quit();
  }
}
