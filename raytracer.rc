extern mod sdl;
extern mod std;

use core::rand::RngUtil;
use core::libc::uint32_t;
use std::timer::sleep;
use std::uv;
use sdl::video::Color;

fn main() {
  let iotask = ~uv::global_loop::get();
  let width = 800;
  let height = 600;

  do sdl::start {
    sdl::init([sdl::InitVideo]);
    sdl::wm::set_caption("rust-sdl demo - video", "rust-sdl");

    let rng = rand::Rng();
    let screen = match sdl::video::set_video_mode(width, height, 32, [sdl::video::HWSurface],
                                                              [sdl::video::DoubleBuf]) {
      Ok(screen) => screen,
      Err(err) => fail!(fmt!("failed to set video mode: %s", err))
    };

    let mut i = 0;
    let mut image = core::vec::from_elem(600, core::vec::from_elem(800, 0u32));
    for int::range(0, width) |x| {
      for int::range(0, height) |y| {
        let screen_raw = unsafe { *screen.raw };
        image[y][x] = rng.gen::<sdl::video::Color>().to_mapped(screen_raw.format);
      }
    }

    loop main: {
      loop event: {
        match sdl::event::poll_event() {
          sdl::event::QuitEvent => break main,
          sdl::event::NoEvent => break event,
          _ => {}
        }
      }
      screen.with_lock(|pixels| {
        unsafe {
          let pixels: &mut [uint32_t] = cast::transmute(pixels);
          let pitch = ((*screen.raw).pitch) as int;
          for int::range(0, width) |x| {
            for int::range(0, height) |y| {
              pixels[y * pitch / 4 + x] = image[y][x];
            }
          }
        }
      });
      screen.flip();
    }

    sdl::quit();
  }
}
